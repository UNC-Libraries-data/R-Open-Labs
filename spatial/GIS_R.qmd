---
title: "GIS in R"
author: 
  name: University of North Carolina at Chapel Hill
execute:
  echo: true
format: 
  html:
    theme: spacelab
    toc: true
    toc-location: left
    page-layout: article
---

## Background on R

This workshop assumes a basic familiarity with the R programming language and some exposure to GIS concepts like projections.

If you'd like a refresher on R, we suggest the [R For Data Science](https://r4ds.hadley.nz/) free e-book and the lessons from our [beginR workshops](https://tarheels.live/beginr/lessons/), including [setup instructions for R and R Studio](https://unc-libraries-data.github.io/R-Open-Labs/week1_Introduction/R_OpenLabs_Introduction.html#setup-r-r-studio).

## Important packages

### Basic packages

As a refresher, in R we install packages from CRAN (The Comprehensive R Archive Network) with the following code:

`install.packages(c('tidyverse','scales'))`

You'll only need to install packages once, then you'll load them into your session with:

```{r}
#| message: false
#| warning: false
library(tidyverse)
```

We'll use the `tidyverse` family of packages to do non-spatial data manipulation today.

#### A note on pipes:

Today we'll use the base R pipe (`|>`) as our default. Some attendees may be more familiar with the `magrittr` pipe (`%>%`). The two work very similarly and should usually be interchangeable. If you'd like to use the base R pipe with R Studio's pipe shortcut (CTRL/CMD + SHIFT + m), you can change the default setting in **Tools \> Global Options \> Code \> Use native pipe operator, \|\> (requires R 4.1+)**.

### Spatial packages

For spatial processing we'll use the following packages today:

```         
install.packages(c('sf','nngeo','tidycensus','tigris','arcgislayers','tmap','ggmap'))
```

```{r}
#| message: false
#| warning: false
#Spatial processing
library(sf)
library(nngeo)

#Getting spatial data
library(tidycensus)
library(tigris)
library(arcgislayers)

#Thematic mapping
library(tmap)
library(ggmap)
```

The `sf` packages will be our main spatial processing tool for today. We'll use `nngeo` to do some nearest-neighbor calculations.

We'll explore some of the most common packages for easily loading spatial data: `tidycensus` for census data, `tigris` for census boundaries, and \`arcgislayers for loading data from ESRI Data Services.

Finally we'll use `ggplot` from the tidyverse to do some basic mapping and explore extensions with `tmap` for thematic mapping and `ggmap` for baselayers.

## Data:

### CSVs / Tabular data

Most people first encounter spatial data through spatial points inside a larger table. These can be CSV or any other common tabular format.

### Shapefiles and Geopackages

Shapefiles are an older format with some significant limitations (like variable name lengths!), but they're important to be familiar with because they're very very common and quirky. Despite the name, a shapefile is actually a *collection of files that have to be stored together* - anywhere from 3 to 12 files! It's good practice to share them as a zipped folder.

Geopackages are a newer file format that avoid many of the limitations of shapefiles. We'll use geopackages for locally storing outputs from our R scripts.

There are lots of other spatial formats out there like KML, GeoJSON, PostGIS and many more! R can work with many of these but we won't work with them all today.

#### File Geodatabases

### Online Data:

#### `tidycensus` and `tigris`

The [`tidycensus`](https://walker-data.com/tidycensus/) and [`tigris`](https://github.com/walkerke/tigris) packages make it easy to pull census data directly from Census APIs into your R session. `tigris` pulls TIGER/Line data with boundaries and a few fields (FIPS code, Land and Water Area, etc.) for a variety of census geographies. This is great for various mapping and spatial processing tasks and gives more control over feature resolution.

Sometimes you'll also want to retrieve census *data* along with spatial information. `tidycensus` makes it easy to retrieve tables from a variety of census datasets, along with spatial data when relevant.

#### ESRI Data Services with `arcgislayers`

```{r}
furl <- paste0(
  "https://sampleserver6.arcgisonline.com/arcgis/rest/services/",
  "EmergencyFacilities/FeatureServer/0"
)

# use field aliases as column names
sf_layer <- arc_read(furl, alias = "replace")

```

## Basic Maps

The `load_variables` function from `tidycensus` provides a list of the available tables and variables for a given year and census survey, for example 5-year ACS data below:

```{r}
ac5_vars <- load_variables(year=2024, dataset = "acs5")
```

Let's load B01001_001, the total population of the tract, to start with.

```{r}
#| message: false
nc_tracts<- get_acs(geography = "tract", state = "NC", variables = c("B01001_001","B01001A_001","B01001C_001"),
        output = "wide", geometry = TRUE, year = 2024, cache_table = TRUE,
        progress_bar = FALSE)
```

We can quickly plot `sf` data with the `plot` function. We'll use `ggplot` to make more complicated maps later on!

```{r}
plot(nc_tracts['B01001_001E'],border=NA)
```

We can also work with `sf` objects like normal dataframes:

```{r}
hist(nc_tracts$B01001_001E, breaks = 100)
```

Which tracts are over 15,000 population?

```{r}
nc_tracts |> 
  filter(B01001_001E>15000)
```

Since all of these tracts are in Wake County, let's take a closer look at Wake County and the triangle?

We'll use the list of counties in the Combined Statistical Area

```{r}
tri_counties <- c('37037','37063','37069','37085','37101','37105','37135',
                  '37145','37181', '37183')

tri_tracts <- nc_tracts |> 
  mutate(county_fips = str_sub(GEOID,1,5)) |> 
  filter(county_fips %in% tri_counties)
```

```{r}
plot(tri_tracts['B01001_001E'],border = NA)
```

It might be helpful to add the county boundaries to this! Since we don't need any county data, we can pull county information from tigris with the `counties` function, then filter to our Triangle counties.

```{r}
#| messsage: False
tri_counties <- counties(state="NC", progress_bar = FALSE) |> 
  filter(GEOID %in% tri_counties) 
```

Once we start layering data, it's a good idea to move to `ggplot` based plots!

```{r}
ggplot()+
  #color=NA removes borders
  geom_sf(data = tri_tracts, aes(fill = B01001_001E), color=NA)+
  #counties, white border, no fill color and adjusted linewidth
  geom_sf(data = tri_counties, color = "grey80", fill=NA, lwd = 0.8)+
  scale_fill_viridis_c()+
  theme_minimal()
```

Let's normalize these tract populations back to their 2020 populations to look directly at growth. We don't need geometries this time since we'll join this to the existing tract boundaries.

```{r}
acs_vars20 <- load_variables(year=2020, dataset="acs5")
tri_tract_pop_20 <- get_acs(geography = "tract", state = "NC", variables = c("B01001_001"),
        output = "wide", geometry = FALSE, year = 2020, cache_table = TRUE,
        progress_bar = FALSE) |> 
  rename(pop20 = B01001_001E) |> 
  select(GEOID, pop20)

tri_tract_chg <- left_join(tri_tracts, tri_tract_pop_20, by = 'GEOID') |> 
  mutate(pop_change = B01001_001E-pop20,
         pop_change_pct = pop_change/pop20)


```

```{r}
ggplot()+
  geom_sf(data = tri_tract_chg, aes(fill = pop_change_pct), color=NA)+
  geom_sf(data = tri_counties, color = "grey80", fill=NA, lwd = 0.8)+
  scale_fill_gradient2(low="red",high="blue", mid="white", labels=scales::percent)+
  theme_minimal()
```

## Plotting XY data from a non-spatial dataframe

Often, you'll have spatial data

```{r}
housing_raw <- read_csv('data/nc_public_housing.csv')
head(housing_raw)
```

```{r}
housing <- st_as_sf(housing_raw, 
                    coords=c('X','Y'),
                    crs = 4326)
```

We can check or **define** the crs (not project into a new crs - this will not change your dataset or coordinates!) with `st_crs`.

```{r}
st_crs(housing)
```

```{r}
#basemaps package map services use Web Mercator (ESPG: 3857)
basemaps::basemap_ggplot(ext = st_bbox(housing), map_service = "carto")+
  geom_sf(data = st_transform(housing, crs = 3857))+
  ggmap::theme_nothing()
```

We can add a state boundary and some space using `tigris` and `st_buffer`.

```{r}
nc_boundary <- states() |> 
  filter(STUSPS=="NC") |> 
  st_transform(crs = 3857)

basemaps::basemap_ggplot(ext = st_bbox(st_buffer(nc_boundary, 
                                                 dist = 100000)), #distance in meters for geographic coordinates
                         map_service = "carto")+
  geom_sf(data = st_transform(housing, crs = st_crs(3857)))+
  geom_sf(data = nc_boundary, fill=NA)+
  ggmap::theme_nothing()
```

```{r}
nc_boundary <- states() |> 
  filter(STUSPS=="NC") |> 
  st_transform(crs = 3857)

basemaps::basemap_ggplot(ext = st_bbox(st_buffer(nc_boundary, 
                                                 dist = 100000)), #distance in meters for geographic coordinates
                         map_service = "carto")+
  geom_sf(data = st_transform(housing, crs = st_crs(3857)),
          aes(color = UR))+
  geom_sf(data = nc_boundary, fill=NA)+
  ggmap::theme_nothing()+
  theme(legend.position="right")
```

Let's add state maintained roads to the map!



**TO DO**

-   Pull in state maintained roads from ESRI not downloaded shapefile.
-   Spatial join public housing to counties
    -   Two layers don't match example!
    -   Use projected coordinates
-   Lean into spatial analysis/ processing, skip the exercise 5 stuff.
-   Bare minimum map elements for R users
    -   Inset map, ggspatial (compass, scale etc.)
    -   Using a projection that makes sense

## Quick note on projections

### Checking and specifying projections

## Spatial Operations

### Spatial Filtering

### Buffering

### Spatial Joins

#### Nearest Neighbors with `nngeo`

## Plotting Data:

### `sf` and `ggplot`

### `tmap`

## Other useful packages:

### Rasters

There are two major raster packages to know about! `terra` is the successor to the `raster` package and works well for most simple rasters. `stars` is a better fit for cubes of data - think rasters with many many layers covering lots of different time points. `stars` itself is short for "Spatiotemporal Arrays"!

### Leaflet

### Other data formats

geoparquet, duckDB

### `spatialreg`
